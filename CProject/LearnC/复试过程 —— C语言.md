# 复试过程 —— C语言

__*Notice*__

> 可以在代码中平白无故的来一对大括号无所谓,C 编译器不会认为有问题。
>
> 程序写的是步骤，不是关系，也不是说明。

## 框架一 —— 数据类型及运算

#### 1. 数据类型及占用大小

+ const 是一个修饰符，加在int的前面，用来给这个变量加上一个 const（不变的）的属性。这个**const 的属性表示这个变量的值一旦被初始化，就不能在修改了**。

+ 若试图对常量做修改，把它放在赋值运算符的左边，就会被编译器发现，指出为一个错误。

+ **sizeof() 是静态运算符，他的结果在编译时刻就确定了，以及不要再 sizeof 中做运算，因为根本不会做运算**。

+ 补码，对于 -a ，其补码就是 0 - a，实际上是  2 的 n 次方 - a ，n 是这种类型的位数。

  意义：补码和原码可以加出一个溢出的 0 。

+ **unsigned 的初衷并非扩展数能表达的范围，而是为了做纯二进制运算，主要是为了移位(结合补码机制来思考)**。

#### 2. 运算符与表达式

- 算数运算符和算数表达式

  1. **基本的算数运算符五个：+ - * / %**

     __*Notice*__

  > - 两个数相除，结果仍为整数（也只能是整数），__商向下取整__，即整除运算。
  > - 10 和 10.0 在 C 中是完全不同的数，10.0 为浮点数
  > - 若参加+、-、*、/运算的两个数中有一个为__浮点数__,则结果是 **double** 型。因为自动转换后所有数都按double型进行运算。
  > - 取模运算符%实际上为数学运算中的求余运算符，其两个**操作对象**都必须是**整数**。**结果的符号与%左边的操作数的符号相同。**
  > - 减法运算符也可作为取负运算，此时为**单目运算符**，除此之外，其他的运算符在使用时，都需要两个操作数，所以为双目运算符。

  2. **算术表达式和运算符的优先级与结合性**

     表达式计算方法：

     > * **按优先级从高到低的顺序依次执行**。优先级如下图所示，

     ![image-20210123113333665](C:\Users\artis\AppData\Roaming\Typora\typora-user-images\image-20210123113333665.png)

     > * 各种运算符的结合方向（**结合性：是指同一优先级运算符的运算先后次序**）为“自左至右”，又称为“左结合性”，及运算对象先与左面的运算符结合。

  3. **自增和自减运算符**

     展现方式：++、--，作用是使变量的值增1或减1，且均为**单目运算符**。

     前缀表示法：先将 i 的值加1/减1，再在表达式中使用；

     后缀表示法：先在表达式中使用 i 的当前值，再将 i 的值加1/减1。

     > 1. ++ 和 -- ，只能用于变量，而不能用于常量或表达式。
     > 2. ++ 和 -- 是单目运算符，其优先级高于基本的算术运算符，与单目运算符 - （取负）的优先级相同。其结合方向是“自右向左”

- 赋值运算符和赋值表达式

  __*Notice*__

  > **赋值的对象只能是变量**，这个数据值既可以是常量，也可以是变量，还可以是**有确定值的表达式**。

  **1. 赋值运算符**

  展现方式： = 

  **2. 赋值表达式**

  展现方式：变量 = 表达式

  作用：将赋值运算符右侧的“表达式”的值赋给赋值运算符左侧的变量，赋值表达式的值就是被赋值的变量的值。

  __*Notice*__

  > 1. 在赋值运算符**左边的量必须是变量**，不能是常量或用上述运算符结合起来的表达式。
  >
  >    > i = 38; 和 j = i；												Right
  >    >
  >    > 38 = i; 和 i + j = 90;										  Wrong
  >
  > 2. 赋值运算可连续进行，且**赋值过程是自右向左进行的**。
  >
  > 3. 赋值运算符的优先级比算术运算符的优先级都低。
  >
  > 4. 赋值表达式的值等于赋值运算符右边表达式的值，而结果的类型由赋值运算符左边变量的类型决定。**若赋值运算符右边值的类型与左边变量的类型不一致，需要把右边值的类型转换成左边变量的类型**。
  >
  > 5. 除了上述基本的赋值运算符外，C语言还提供了另外10个赋值运算符，它们是：
  >
  >    +=	-=	*=	/=	%=	>>=	=<<	&=	|=	^=
  >
  >    后五种是有关位运算的。
  >
  >    __*Notice*__
  >
  >    > 复合赋值运算符的优先级与基本赋值运算符的优先级相同，除了逗号运算符外，赋值运算符的优先级是最低的。

- 关系运算符和关系表达式

  1. **关系运算符**

     展现方式：>	>=	<	<=	优先级相同							高

     ​				   ==	!=				  优先级相同							低

  2. **关系表达式**

     用关系运算符将两个分量连在一起构成的表达式称为关系表达式。关系表达式的值是一个逻辑值，即“真”或“假”。

     **并且连续的关系运算为从左到右运算**。

     ***Notice***
     
     > 规定：以数值0表示“假”，以非0表示“真”。**所有的关系运算符低于算数运算符**。但是比赋值运算符高。

- 逻辑运算符和逻辑表达式

- 位运算符和位表达式

- 条件运算符和条件表达式

- 逗号运算符和逗号表达式

- 其他运算符

- Struct

  - 结构体

- enum

  - 枚举
    - 枚举量只能是 int
    - 声明枚举量的时候可以指定值

- Union

  * 存储
    * 所有的成员共享一个空间
    * 同一时间只有一个成员是有效的
    * union 的大小是其最大的成员
  * 初始化
    * 对第一个成员做初始化

- 静态本地变量

  - 全局生存期，函数内的局部作用域

## 框架二 —— 控制语句

#### 1. 条件控制语句

* if 语句

  展现形式：if (表达式)	表达式;

* if —— else 语句

  展示形式： if (表达式){

  ​						表达式；

  ​					} else {

  ​						表达式;

  ​					}

* if —— else if —— else 语句

  展现形式： if (表达式){

  ​						表达式;

  ​					} else if (表达式) {

  ​						表达式;

  ​					} else {

  ​						表达式;

  ​					}

  __*Notice*__

  > 1. else 总和最近的 if匹配
  > 2. 如有大括号则注意区分括号内的 if 不一定和最近的 else 匹配
  > 3. 缩进不代表匹配
  > 4. 在**条件控制语句**中尽量设计成单一出口

* switch —— case 语句

  展现形式： switch (控制表达式) {

  ​						case 常量:

  ​							表达式;

  ​							break;

  ​						......

  ​						default:

  ​							表达式；

  ​					}

  __*Notice*__

> 1. switch 语句中**控制表达式**只能是整数型结果。
> 2. 常量可以是常数，**也可以是常数计算的表达式**。
> 3. switch 语句可以看做是一种基于计算的跳转，计算控制表达式的值后，程序会跳转到相匹配的 case (分支标号) 处。分支标号只是说明 switch 内部位置的路标，**在执行完分支中的最后一条语句后，如果后面没有break，就会顺序执行到下面的 case 里去，直到遇到一个 break，或者 switch 结束为止**。

#### 2. 循环控制语句

* while 语句

  展现形式： while (条件) {

  ​						循环体;

  ​					}

  __*Notice*__

  > 1. 当条件成立时，执行循环体内容。

* do - while 语句

  展现形式： do{

  ​						循环体;

  ​					} while (循环条件);

  __*Notice*__

  > 1. 在进入循环的时候不做检查，而是在执行完一轮循环体代码后再检查循环条件是否满足，如果满足则继续下一轮循环，否则结束循环。
  > 2. **do - while 语句结尾有 “;”**。

* for 语句

  展现形式： for(初始条件;循环继续条件;循环每轮要做的动作){

  ​						循环体;

  ​					}

  表述形式： for (count = 10;count > 0;count--) 可以理解为“对于一开始的 count = 10，当 count > 0 时，重复做循环体，每一轮循环在做完循环体内语句后，使得 count--。”

  __*Notice*__

  > 1. for 循环的条件判断是在一开始就做的与 while 一致。
  > 2. for 循环中的每一个表达式都是可以省略的。
  > 3. for (; 条件 ; ) == while (条件)

__*Tips for loops*__

> * 如果有固定次数，用 for
> * 如果必须执行一次，用 do - while
> * 其他情况用 while

* break VS continue

  > break: 跳出循环。
  >
  > continue： 跳过循环这一轮剩下的语句进入下一轮。
  >
  > * 只能对它所在的那层循环做

* goto 语句

  表现形式： goto 标号(为自己设置)；

  > * 建议只在多层嵌套循环中的最内层跳到最外层使用 goto 语句，其他不建议使用。

## 框架三 —— 格式化输出/输入



## 框架四 —— 数组与二维数组

#### 1. 一维数组

数组: 是一种容器(放东西的东西)，特点是：

* 其中所有的元素具有相同的数据类型；
* 一旦创建，不能改变大小；
* **数组中的元素在内存中是连续依次排列的**。

定义方法： <类型> 变量名称[元素数量];

__*Notice*__

> * 元素数量必须是**整数**
> * **C99之前**: 元素数量必须是编译时刻确定的字面量
> * int a[0]; 可以存在，**但是无用**。

数组运算：

* 数组变量本身不能被赋值；
* 把一个数组的所有元素交给另一个数组，必须采用遍历；
* **数组作为函数参数时，往往必须再用另一个参数来传入数组的大小**。
  * 不能在 [] 中给出数组的大小
  * 不能再利用sizeof来计算数组的元素个数

#### 2. 二维数组

定义方法： int **a[][5]** = {

​							{0,1,2,3,4},

​							{2,3,4,5,6},

};

__*Notice*__

> * 列数是必须给出的，行数可以由编译器来数
> * 每行一个{},逗号分隔
> * 最后的逗号可以存在，有古老的传统
> * 如果省略，表示补0
> * 也可以用定位(**C99 ONLY**)
> * **同样可以不带大括号填满二维数组**(在内存中二维数组的排列与一维数组一致)

## 框架五 —— 指针

#### 1. 取地址运算符

* 展现形式： &

* 作用目的： 获得变量的地址，**它的操作数必须是变量**。

  __*Notice*__

  > 地址的大小是否与 int 相同取决于编译器 (**int i; printf("%p",&i);**)

#### 2. 指针

指针就是保存地址的变量

__*Notice*__

> int i;	int* p = &i;
>
> int* p,q;	int *p,q			//均表示p是一个int型的指针变量，而q则只是int型变量

* 指针变量

  变量的值是内存的地址

  __*Notice*__

  > * 普通变量的值是实际的值
  > * 指针变量的值是具有实际值的变量的地址

  运算形式： * 是一个单目运算符，用来访问指针的值所表示的地址上的变量

  ​					可以做右值，也可以做左值。

* 指针的使用

  1. 当函数有多个返回值时，例如 swap 函数，无法使用return返回多个值
  2. 当函数有多重状态时，一般可以用return来表示函数的执行状态，指针则带回其他值。

* 指针最常见的错误

  __*Notice*__

  > * **定义了指针变量，还没有指向任何变量，就开始使用指针**。

* 指针与数组的关系

  __*Notice*__

  > * 函数参数表中的数组实际上是指针
  >
  >   * sizeof (a) == sizeof (int *)
  >   * **但是可以使用数组的运算符[]进行运算**。
  >
  > * 数组变量是特殊的指针
  >
  >   * 数组变量本身表达地址，因此int a[10]; int *p = a;	//无需使用 & 取地址符
  >
  >   * 但是数组的单元表达的是变量，需要用 & 取地址。
  >
  >   * **[] 运算符可以对数组做，也可以对指针做**: p[0] <==> a[0];
  >
  >   * *运算符可以对指针做，也可以对数组做: *a = 25;
  >
  >   * 数组变量是const的指针，所以不能被赋值
  >
  >     int a[] <==> int * const a;

* **指针与 const**

  1. **指针是 const**

     表示**一旦得到了某个变量的地址，不能在指向其他变量**。

     > int * const q = &i;	//q 是 const
     >
     > *q = 26；	//OK
     >
     > q++;	// ERROR

  2. **所指是const**

     表示**不能通过这个指针去修改那个变量 (并不能使得那个变量成为const)**

     > const int *p = &i;
     >
     > *p = 26;	//ERROR!  *p 是 const
     >
     > i = 26;	//OK
     >
     > p = &j;	//OK

  3. 判断标准

     判断那个被const了的标志是const在*的前面还是后面

  4. const 数组

     > const int a[] = {1,2,3,4,5,6,};
     >
     > * **数组变量已经是const的指针了，这里的const表明数组的每个单元都是const int**。
     >
     > * **所以必须通过初始化进行赋值**。

* 指针运算

  1. 指针加减

  2. *p++

     * 取出p所指的那个数据来，完事儿之后顺便移到下一个位置去
     * *的优先级虽然高，但是没有++高
     * 常用于数组类的连续空间操作
     * 在某些CPU上，这可以直接被翻译成一条汇编指令

  3. 指针比较

     * <,<=,==,>,>=,!= 都可以对指针做
     * 比较他们在内存中的地址
     * 数组中的单元的地址肯定是线性递增的

  4. 0地址

     * 内存中必然存在0地址，但是0地址通常是个不能随便碰的地址，所以你的指针不应该具有0值
     * 因此可以用0地址来表示特殊的操作：
       * 返回的指针是无效的
       * 指针没有被真正的初始化，即先被初始化为0地址
     * NULL 是一个预定义定义的符号，表示0地址

  5. 指针的类型

     * 无论指向什么类型，**所有的指针的大小都是一样的，因为都是地址**。
     * 但是指向不同类型的指针是不能直接互相赋值的。

  6. 指针的类型转换

     * void* 表示不知道指向什么东西的指针
       * 计算时与char* 相同(但不相通)
     * 指针也可以转换类型
       * int *p = &i; void *q = (void *)p;
         * 这并没有改变p所指的变量的类型，而是让后人用不同的眼光通过p看它所指的变量
         * 即我不在当你是int，我认为你就是个void！

  7. 总结

     ![image-20210225185358130](C:\Users\artis\AppData\Roaming\Typora\typora-user-images\image-20210225185358130.png)



## 框架六 —— 函数

__*Notice*__

> * 函数是一块代码，接受零个或多个参数，做一件事情，并返回零个或一个值。
> * 可以想象成数学中的函数，但不完全一样
>   * y = f(x);
> * C 语言在调用函数时，永远只能传值给函数。

#### 1. 定义与结构

#### 2. 调用函数

1. **函数原型**

   展现形式： 函数头，以分号";"结尾，就构成了函数的原型

   原型目的： 告诉**编译器**这个函数长什么样(**名称**，**参数**(数量及类型)，**返回类型**)

2. **参数传递**

   * 每个函数有自己的变量空间，参数也位于这个**独立**的空间，和其他函数没有任何关系。
   * 我们认为，他们是参数(**函数中的参数**)和值(**调用函数中的值**)的关系。

3. **本地变量**

   展现形式： 本地变量是定义在块内的(**他可以是定义在函数的块内**,**也可以定义在语句的块内**，**甚至可以随便拉一对大括号来定义变量**)；

   ​					程序在运行进入这个块之前，其中的变量不存在，离开这个块，变量就消失了；

   ​					块外边定义的变量在块内仍然有效；

   ​					块内定义了和外面同名的变量则掩盖外面的；

   ​					不能再同一个块内定义同名变量；

   ​					本地变量不会被默认初始化；

   ​					参数在进入函数的时候被初始化；

   __*Notice*__

   > * 函数的每次运行，就产生了一个独立的变量空间，在这个空间中的变量，是函数的这次运行所独有的，称为本地变量
   > * 定义在函数内部的比阿娘就是本地变量
   > * 参数也是本地变量

#### 3. 函数的返回值

__*Tips for Function*__

> * 函数原型如果没有参数建议写为 void f(void) 形式。
>
> * 调用函数时的圆括号里的逗号是标点符号，不是运算符，例如f(a,b) and f((a,b)) 其中前者就是逗号，后者是逗号运算符。
>
> * C 语言不允许函数嵌套定义，可以在其中放置声明

## 框架七 —— 字符串

定义: 以0(整数0)结尾的一串字符

* 0 或 \0 是一样的，但是和 ‘0’ 不同
* 0 标志字符串的结束，但它不是字符串的一部分
* 计算字符串长度的时候不包含这个0
* 字符串以数组的形式存在，以数组或指针的形式访问
* 更多的是以指针的形式
* string.h 中有很多处理字符串的函数

C 语言的字符串是以字符数组的形式存在的

* 不能用运算符对字符串做运算
* 通过数组的方式可以遍历字符串

指针还是数组？

数组: 这个字符串在这里

* 作为本地变量空间自动被回收

指针: 这个字符串不知道在哪儿

* 就是只读，不做任何修改
* 用于处理参数
* 动态分配空间

__*Notice*__

> * 如果要构造一个字符串->数组
> * 如果要处理一个字符串->指针

* **string.h**

  标准输入与输出都是先于shell做交互的